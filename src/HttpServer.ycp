/**
 * File:	modules/HttpServer.ycp
 * Package:	Configuration of http-server
 * Summary:	Data for configuration of http-server, input and output functions.
 * Authors:	Stanislav Visnovsky <visnov@suse.cz>
 *
 * $Id$
 *
 * Representation of the configuration of http-server.
 * Input and output routines.
 */

{

module "HttpServer";
textdomain "http-server";

import "HTTPDData";
//import "NetworkDevices";
import "Progress";
import "Report";
import "Require";
import "Runlevel";
import "Summary";

/**
 * Abort function
 * return boolean return true if abort
 */
global block<boolean> AbortFunction = nil;

/**
 * Required packages
 */
global list<string> required_packages = ["apache2"];

/**
 * Data was modified?
 */
global boolean modified = false;

global boolean configured = false;

global boolean proposal_valid = false;

/**
 * Write only, used during autoinstallation.
 * Don't run services and SuSEconfig, it's all done at one place.
 */
global boolean write_only = false;


/**
 * Data was modified?
 * @return true if modified
 */
global define boolean Modified() ``{
    y2debug("modified=%1",modified);
    return modified;
};

include "http-server/routines.ycp";

/**
 * HTTP server settings
 */
global map<string,any> settings = $[
    "modules" : GetModules(),
    "Listen" : [ $["PORT":"80"] ],
    "default" : $[
	"ServerName" : "www.example.com",
//	"DocumentRoot" : "/srv/www/htdocs",
	"ServerAdmin" : "webmaster@example.com",
// CustomLog - no defaults
// ErrorLog - no defaults
    ],
    "settings" : $[
	"enabled" : false,// should be the service started?
	"firewall" : true, // should we adapt firewall?
	"firewall_started" : false, // is firewall enabled?
    ]
];

global define map<string,any> Settings ()
{
    return settings;
}

/**
 * List of status of modules modified
 */
global list<string> modules_modified = [];

/**
 * Mapping of IPs to network devices
 */
global map<string,string> ip2device = $[];

/**
 * List of maps $[ "port": port, "interface": "all" | "eth0", ... ] containing
 * description of listen statement already configured in firewall. Read in
 * Read, used in Write.
 */
global list< map<string,string> > listen4firewall = [];

global string document_root = "";

/****************************** local data ************************************/

/**
 * List of httpd.conf options to be stored in settings part, not in hosts
 */
list<string> server_settings = [ "ErrorLog", "CustomLog" ];

/**
 * List of options which allow multiple keys
 */
list<string> multiple_settings = ["Include", "CustomLog"];

map<string,string> sysconfig_values = $[
    "apache_access_log"	: "APACHE_ACCESS_LOG",
    "ServerAdmin"	: "APACHE_SERVERADMIN",
    "ServerName"	: "APACHE_SERVERNAME",
//    "DocumentRoot"	: "APACHE_DOCUMENT_ROOT",
];

/**
 * Hack to hide special PHP module handling
 * FIXME: remove for the next version
 */
boolean php_hack = false;

/************************** end of local data *********************************/


/**
 * Read all http-server settings
 * @return true on success
 */
global define boolean Read() ``{

    /* HttpServer read dialog caption */
    string caption = _("Initializing HTTP Server Configuration");

    integer steps = 3;

    // We do not set help text here, because it was set outside
    Progress::New( caption, " ", steps, [
	    // translators: progress stage
	    _("Check the environment"),
	    // translators: progress stage
	    _("Read Apache2 configuration"),
	    // translators: progress stage
	    _("Read network configuration")

	], [
	    // translators: progress step
	    _("Checking the environment..."),
	    // translators: progress step
	    _("Reading Apache2 configuration..."),
	    // translators: progress step
	    _("Reading network configuration..."),
	    // translators: progress finished
	    _("Finished")
	],
	""
    );

    // check the environment
    if(Abort()) return false;
    Progress::NextStep();

    // check httpd.conf
    if( SCR::Read( .target.lstat, "/etc/apache2/httpd.conf" ) == $[] ) {
	// translators: error message, %1 is the file name of expected configuration file
	Report::Error( sformat( _("The configuration file '%1' does not exist."), "/etc/apache2/httpd.conf" )  );
	return false;
    }

    // check sysconfig
    if( SCR::Read( .target.lstat, "/etc/sysconfig/apache2" ) == $[] ) {
	if( SCR::Execute( .target.bash, "cp /var/adm/fillup-templates/sysconfig.apache2 /etc/sysconfig/apache2" )
	    != 0 ) {
	// translators:: error message
	    Report::Error( sformat( _("Cannot create sysconfig file '%1'."), "/etc/sysconfig/apache2" ) );
	    return false;
	}
    }

    // check listen.conf
    if( SCR::Read( .target.lstat, "/etc/apache2/listen.conf" ) == $[] ) {
	// translators: warning message, %1 is the file name of expected configuration file
	Report::Warning( sformat( _("The configuration file '%1' does not exist."), "/etc/apache2/listen.conf" )  );
	// create empty file
	if( ! SCR::Write( .target.string, "/etc/apache2/listen.conf", "" ) )
	{
	// translators:: error message
	    Report::Error( sformat( _("Cannot create the file '%1'."), "/etc/apache2/listen.conf" ) );
	    return false;
	}
    }

    // read current settings from httpd.conf and sysconfig
    Progress::NextStage();
    
    // read hosts
    HTTPDData::ReadHosts();
    HTTPDData::ReadListen();
    HTTPDData::ReadModules();
    
    // FIXME: special handling of PHP
//    if( settings["modules", "php4", "status"]:false == true &&
//	! Require::AreAllPackagesInstalled(["apache2-mod_php4"]) )
//    {
//	php_hack = true;
//	settings["modules", "php4", "status"] = false;
//    }

    // read the rest of the configuration from sysconfig
    settings["apache_access_log"] = SCR::Read( .sysconfig.apache2."APACHE_ACCESS_LOG" );
    string value = (string) SCR::Read( .sysconfig.apache2."APACHE_SERVERADMIN" );
    if( value != nil ) settings["default","ServerAdmin"] = value;
    value = (string) SCR::Read( .sysconfig.apache2."APACHE_SERVERNAME" );
    if( value != nil ) settings["default","ServerName"] = value;
    value = (string) SCR::Read( .sysconfig.apache2."APACHE_DOCUMENT_ROOT" );
    // store document root somewhere else
    if( size(value) > 0 ) document_root = value;
    else {
	// try defaulthost.conf
	value = (string) SCR::Read( .etc.apachedefault.DocumentRoot );
	if( value != nil ) document_root = value;
    }

    // check the service status
    settings["settings", "enabled" ] = Runlevel::ServiceEnabled( "apache2" );

    if(Abort()) return false;

    Progress::NextStage();

    // read current settings for firewall and network
// FIXME:    Progress::off();
//    SuSEFirewall::Read();
//    NetworkDevices::Read();

    // generate the map: static IP -> device
    // TODO: IP aliases
    ip2device = $[];
// FIXME:    list devs = NetworkDevices::Locate("BOOTPROTO", "static");
//    foreach(string dev, devs, {
//	string ip = NetworkDevices::GetValue(dev, "IPADDR");
//	if(ip != nil && ip != "") ip2device[ip] = dev;
//    });

    // generate the map of our settings in firewall
    listen4firewall = maplist( map<string,string> l, settings["Listen"]:[], ``{
	if( l["ADDRESS"]: nil != nil ) {
	    string ni = ip2device["ADDRESS"]:"";
	    if( ni != "" ) {
		return $[ "port": l["PORT"]:"80", "interface": ni ];
	    } else {
		return $[ "port": l["PORT"]:"80", "interface": "all" ];
	    }
	}
    });

    settings["settings", "firewall_started"] = false;// FIXME:lookup( SuSEFirewall::Export(), "start_firewall", false );

    Progress::on();

    // translators: progress step
    ProgressNextStage(_("Finished"));

    if(Abort()) return false;
    modified = false;

    configured = true;

    return true;
}

/**
 * Write all http-server settings
 * @return true on success
 */
global define boolean Write() ``{

    /* HttpServer read dialog caption */
    string caption = _("Saving HTTP Server Configuration");

    integer steps = 4;

    // We do not set help text here, because it was set outside
    Progress::New(caption, " ", steps, [
	    // translators: progress stage 1/4
	    _("Write the Apache2 settings"),
	    // translators: progress stage 2/4
	    settings[ "settings", "firewall"]:false ?_("Modify firewall") :
		// translators: progress stage 2/4
		_("Modify firewall (skipped)"),
	    // translators: progress stage 3/4
	    _("Run SuSEconfig"),
	    settings["settings", "enabled"]:false ?
		// translators: progress stage 4/4
		_("Enable Apache2 service")
		// translators: progress stage 4/4
		: _("Disable Apache2 service")
	], [
	    // translators: progress step 1/4
	    _("Writing the settings..."),
	    // translators: progress step 2/4
	    settings[ "settings", "firewall"]:false ?_("Modifying firewall...") :
		// translators: progress step 2/4
		_("Skipping firewall modification..."),
	    // translators: progress step 3/4
	    _("Running SuSEconfig..."),
	    settings["settings", "enabled"]:false ?
		// translators: progress step 4/4
		_("Enabling Apache2 service...")
		// translators: progress step 4/4
		: _("Disabling Apache2 service..."),
	    // translators: progress finished
	    _("Finished")
	],
	""
    );

    // write Apache2 settings

    // write sysconfig
    list<string> modlist = [];
    foreach( string mod, map status, settings["modules"]:$[], ``{
	if( status["status"]: false ) {
	    modlist = add( modlist, mod );
	}
    });

    list<string> rpms = HTTPDData::GetModulePackages();

    if( php_hack ) {
	settings[ "modules", "php4", "status" ] = true;
    }

/*
    // install rpms only for changed modules
    list rpms = [];
    foreach( string mod, modules_modified, ``{
	if( settings[ "modules", mod, "status"]: false ) {
	    rpms = union( rpms, settings[ "modules", mod, "requires"]:[] );
	}
    });
*/

    SCR::Write( .sysconfig.apache2."APACHE_MODULES", mergestring( modlist, " " ) );
    if( !SCR::Write( .sysconfig.apache2, nil ) ) {
	// translators: error message
	Report::Error( sformat(_("Cannot write '%1'."), "/etc/sysconfig/apache2" ) );
    }

    // install required RPMs for modules
    // TODO: php4 does not work with thread-based apache2 config
    Require::RequireAndConflictTarget( rpms, [], _("The enabled modules require
installation of some of these additional packages:
%1
Install them now?
") );

    // write httpd.conf

    // write hosts
    HTTPDData::WriteHosts ();

    // write listen
    if( /*FIXME: ! HTTPD::WriteListen (settings["Listen"]:[])*/ false ) {
	// TODO: configuration file placing can change
	Report::Error( sformat(_("Cannot write '%1'."), "/etc/apache2/listen.conf" ) );
    }


    // global settings
    foreach( string key, any value, settings["settings"]:$[], ``{
	// filter internal and other options
	if( !contains( ["enabled", "firewall", "firewall_started" ], key ) )
	    SCR::Write( add(.etc.httpd, key), value );
    });
    // TODO: virtual hosts, SSL etc
    if( !SCR::Write( .etc.httpd, nil ) ) {
	// TODO: configuration file placing can change
	Report::Error( sformat(_("Cannot write '%1'."), "/etc/apache2/httpd.conf" ) );
    }

    if( !SCR::Write( .sysconfig.apache2, nil ) ) {
	// translators: error message
	Report::Error( sformat(_("Cannot write '%1'."), "/etc/sysconfig/apache2" ) );
    }


    Progress::NextStage();

    // modify firewall
    if( settings["settings", "firewall"]: false && settings["settings", "firewall_started"]:false ) {
    
	// FIXME: adapt firewall settings

	// delete all our firewall settings
//	foreach( map listen, listen4firewall, ``{
//	    SuSEFirewall::RemoveService( listen["port"]:"www", "TCP", listen["interface"]:"all" );
//	});

	// setup the new firewall settings
//	y2debug( "Writing Listen settings to firewall: %1", settings["Listen"]:[] );
//	foreach( map<string,string> l, settings["Listen"]:[], ``{
	    // FIXME: interface handling
//	    SuSEFirewall::AddService( l["PORT"]:"www", "TCP", l["interface"]:"all" );
//	});

	Progress::off();
//	SuSEFirewall::Write();
	Progress::on();
    }

    Progress::NextStage();

    // in autoyast, quit here
    // Wrong, service still has to be enabled...
    // if( write_only ) return true;

    // run SuSEconfig
	if (!write_only) {
    if( SCR::Execute( .target.bash, "/sbin/SuSEconfig --module apache2" ) != 0 ) {
	// translators: error message
	Report::Error(_("SuSEconfig script failed!") );
    }
	}

    Progress::NextStage();

    // service enable or disable
    boolean res = true;
    if( settings["settings", "enabled"]:false ) {
	res = res && Runlevel::ServiceAdjust( "apache2", "enable" );
	if (!write_only)
		res = res && (Runlevel::RunInitScript( "apache2", "restart" ) == 0);
    } else {
	res = res && Runlevel::ServiceAdjust( "apache2", "disable" );
	if (!write_only)
		res = res && (Runlevel::RunInitScript( "apache2", "stop" ) == 0);
    }
    // translators: error message
    if( !res ) Report::Error( sformat( _("Cannot adjust '%1' service."), "apache2" ) );

    // translators: progress finished
    ProgressNextStage(_("Finished"));

    if(Abort()) return false;
    return true;
}

/**
 * Get all http-server settings from the first parameter
 * (For use by autoinstallation.)
 * @param s The YCP map to be imported
 * @return boolean True on success
 */
global define boolean Import (map s) ``{

    map old_modules = GetModules();

    settings[ "settings" ] = s[ "settings" ]: $[ "enabled" : false ];

    settings[ "modules" ] = listmap( map value, s["modules"]:[],
	``{ string n = value["name"]:"";
	    if( n != "" ) {
		string old_desc = (string) eval(old_modules[ n, "description" ]:"");
		return $[ n :
		    $[ "status": value["state"]:false,
		       "description": old_desc
		    ]
		];
	    } else return (map)nil;
	   } );

    settings[ "default" ] = s[ "default" ]: $[
	"ServerName" : "www.example.com:80",
//	"DocumentRoot" : "/srv/www/htdocs",
	"ServerAdmin" : "webmaster@example.com",
    ];

    // FIXME: do a transformation from 9.0
//    settings["Listen"] = s[ "defaulthost", "Listen" ]: [ $["PORT":"80"] ];

    modified = false;
    configured = true;

    return true;
}

/**
 * Dump the http-server settings to a single map
 * (For use by autoinstallation.)
 * @return map Dumped settings (later acceptable by Import ())
 */
global define map Export () ``{
    map result = $[
	"modules": maplist( string mod, map state, settings["modules"]:$[], ``(
	    $[ "name": mod, "state" : state["status"]:false ]
	)),
	"default": settings["default"]:$[],
	"settings": settings["settings"]:$[],
	"Listen": settings["Listen"]:$[]
    ];

    configured = true;

    return result;
}

/**
 * Create a textual summary for the current configuration
 * @return summary of the current configuration
 */
global define list Summary() ``{

    string nc = Summary::NotConfigured ();

    string summary = "";

    if( configured ) {
        // summary item: an option is turned on
        if( settings["settings", "enabled"]:false )
	    // translators: autoyast summary text, server status
            summary = Summary::AddLine(summary, _("Apache2 server is <i>enabled</i>") );
        else
	    // translators: autoyast summary text, server status
            summary = Summary::AddLine(summary, _("Apache2 server is <i>disabled</i>") );

	// translators: autoyast summary text, %1 is path for default host document root
//	summary = Summary::AddLine(summary, sformat( _("Default host stored in %1"), settings["defaul", "DocumentRoot"]:
//	    "/srv/www/htdocs" ) );

    } else {
        summary = Summary::AddLine(summary, nc );
    }

    return [ summary, [] ];
}

/**
 * Enable HTTP service.
 *
 * @param on 	the new status of the service
 */
global define void enableService(boolean on) ``{
    if( settings["settings", "enabled"]:false == on ) return;
    settings["settings", "enabled"] = on;
    modified = true;
}


/**
 * Return required packages for auto-installation
 * @return map of packages to be installed and to be removed
 */
global define map AutoPackages() ``{
       if( !Require::IsAnyPackageInstalledTarget( ["apache2-prefork", "apache2-metuxmpm", "apache2-worker"] ) ) {
           // add a default MPM - prefork because of the PHP4 compatibility
        required_packages = (list<string>)union (required_packages, ["apache2-prefork"] );
       }

       return ($["install": required_packages, "remove": []]);

}

/* EOF */
}
