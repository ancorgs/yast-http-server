/**
 * File:	modules/HttpServerWidgets.ycp
 * Package:	Configuration of http-server
 * Summary:	Widgets used by HTTP server configuration
 * Authors:	Jiri Srain <jsrain@suse.cz>
 *		Stanislav Visnovsky <visnov@suse.cz>
 *
 * $Id$
 */

{
    module "HttpServerWidgets";

    textdomain "http-server";

    import "Directory";
    import "Mode";
    import "IP";
    import "Label";
    import "Popup";
    import "Report";
    import "Service";
    import "String";
    import "LogView";
    import "TablePopup";
    import "HttpServer";
    import "YaST::HTTPDData";
    
    include "http-server/helps.ycp";

global string currenthost = "default";
global string directory_param_regexp = "Directory \"?([^\"]+)\"?";

boolean update_contents = false;

map<string, any> ssl_options = (map<string, any>)SCR::Read (.target.ycp, Directory::datadir + "/all-ssl-options.ycp");

string item2listen( string network, string port );

global string get_host_value ( string keyword, list< map<string, any> > host, string default )
{
    string ret = default;
    
    foreach( map<string, any> option, host, ``{
	if (option["KEY"]:nil == keyword)
	{
	    ret = option["VALUE"]:default;
	    break;
	}
    });
    
    // drop quotes, if exist
    ret = regexpsub (ret, "\"?([^\"]*)\"?", "\\1");
    
    return ret;
}

global list< map<string,any> > set_host_value ( string keyword, list< map<string, any> > host, any value )
{
    integer index = 0;
    foreach( map<string, any> option, host, ``{
	if (option["KEY"]:nil == keyword)
	{
	    break;
	}
	index = index + 1;
    });
    
    if (index >= size(host))
    {
	// adding a new option
	host[index] = $[ "KEY" : keyword , "VALUE" : value ];
    }
    else
    {
	host[index, "VALUE"] = value;
    }

    return host;
}

global boolean validate_servername (string id, string key, map event) ``{
    import "Hostname";
    string value = (string)UI::QueryWidget (`id (id), `Value);
    if (!Hostname::CheckFQ (value))
    {
	Popup::Error (_("Invalid server name.") 
	    + "\n\n" 
	    + Hostname::ValidFQ ());
	return false;
    }
    else
    {
	return true;
    }
}


global boolean validate_serverip (string id, string key, map event) ``{
    import "IP";
    string value = (string)UI::QueryWidget (`id (id), `Value);
    if (!IP::Check (value))
    {
	Popup::Error (_("Invalid IP address."));
	return false;
    }
    else
    {
	return true;
    }
}

/*********************************** inital overview table ********************************/

global symbol showAccessLogPopup (any key, map event);
global symbol showErrorLogPopup (any key, map event);

list <string> host_ids = nil;

void OverviewInit (string widget)
{
    string listen_summary = mergestring ( 
	maplist( map<string,any> listen, YaST::HTTPDData::GetCurrentListen(), 
	    ``(item2listen (listen["ADDRESS"]:"",listen["PORT"]:"80"))), ", ");
	    
    // limit the text to 50 chars
    if (size (listen_summary) > 50) listen_summary = substring (listen_summary, 0, 50) + "...";
	    
    y2milestone ("Current listen: %1", YaST::HTTPDData::GetCurrentListen() );
	    
    string default_host = get_host_value( "ServerName", YaST::HTTPDData::GetHost ("default"), "");
    if (default_host == "")
    {
	// if the default host does not have a servername specified, use it's
	// document root, %1 is the full path
	default_host = sformat( _("in %1"), get_host_value( "DocumentRoot", YaST::HTTPDData::GetHost ("default"), ""));
    }
    
    host_ids = YaST::HTTPDData::GetHostsList ();

    y2milestone ("Current listen: %1", host_ids );

    string hosts = mergestring (
	maplist( string host, host_ids, ``{
	    return get_host_value ( "ServerName", YaST::HTTPDData::GetHost (host), "" );
	}), ", ");

    // limit the text to 50 chars
    if (size (hosts) > 50) hosts = substring (hosts, 0, 50) + "...";

    UI::ChangeWidget (`overview_table, `Items, 
	[
	    // translators: table entry for Listen statements
	    `item ( `id(`listen), _("Listen on"), listen_summary ),
	    // translators: table entry for server modules
	    `item ( `id(`modules), _("Modules"), "" ),
	    // translators: table entry for default host
	    `item ( `id(`default), _("Default Host"), default_host ),
	    // translators: table entry for all configured hosts
	    `item ( `id(`hosts), _("Hosts"), hosts ),
	]);
}

symbol OverviewHandle (string table, map event)
{
    if (event["ID"]:nil == `edit)
    {
	symbol id = (symbol)UI::QueryWidget (`overview_table, `CurrentItem);
#	currenthost = "default";	// ensure to edit the default host, if `default was selected
	return id;
    }
    // handle menu button entries
    else if( event["ID"]:nil == `show_access_log ) {
	return showAccessLogPopup( table, event );
    }
    else if( event["ID"]:nil == `show_error_log ) {
	return showErrorLogPopup( table, event );
    }

    
    return nil;
}

map<string, any> overview_widget = $[
    "widget"		: `custom,
    "custom_widget"	: 
	`VBox(
	    // translators: table heading
	    `Table (`id( `overview_table), `header( _("Option")
		// translators: table heading
		, _("Value") )),
	    `HBox(
		`PushButton ( `id(`edit), Label::EditButton ()),
		`HStretch(),
		// menu button label
        	`MenuButton( _("&Log Files"),
            	    // menu button item
            	    [ `item( `id( `show_access_log ), _("Show &Access Log") ),
            	    // menu button item
            	    `item( `id( `show_error_log ), _("Show &Error Log") )
        	] )
	    )
	),
    "init"		:  OverviewInit,
    "handle"		:  OverviewHandle,
    "help"		:  HELPS["overview_widget"]:"",
];

/******************************************************************************************/

void HostsInit (string widget);
symbol HostsHandle (string table, map event);
list HostsContents (map descr);
boolean HostsDelete (any opt_id, string opt_key);
global boolean HostIsDefault (any widget, string opt_key);
global string HostsMapId2Key( map desc, string id );
global string HostDocumentRootSummary( string key, any id );
global string HostName (string id);

map<string, any> hosts_widget = (map<string, any>)TablePopup::CreateTableDescr (
	$["add_delete" : true, 
	      "up_down" : false, 
	      "unique_keys" : true,
	      "changed_column" : true]
	, $[
	    "init" : HttpServerWidgets::HostsInit,
	    "handle" : HttpServerWidgets::HostsHandle,
	    "ids" : HttpServerWidgets::HostsContents,
	    "option_delete" : HttpServerWidgets::HostsDelete,
	    "help" : HELPS["hosts"]:"",
	    "fallback": $[
		"summary" : HttpServerWidgets::HostDocumentRootSummary,
		"changed" : HttpServerWidgets::HostIsDefault,
		"label_func" : HttpServerWidgets::HostName,
	    ],
	]);

void HostsInit (string widget)
{
    TablePopup::TableInit(hosts_widget, widget);
}

map<string,string> AskNewInfo (string servername, string ip)
{
    if (size (servername) == 0)
    {
	import "DNS";
	import "Hostname";
	// suggest reasonable value
	servername = Hostname::MergeFQ (DNS::hostname, DNS::domain);
	// maybe we should check, if there is such host already
    }
    
    list ips = maplist( string ip, string dev, HttpServer::ip2device, ``( ip ) ) ;

    UI::OpenDialog (
	`VBox(
	    // translators: popup description on changing the default host
	    // the old default host is changed to a virtual one, but it may
	    // miss some needed information. the popup asks to set them.
	    `Label( _("The current default host will be replaced by 
the new host and will become a virtual host.

But, the current default host does not have
the IP address or the server name specified.
Therefore, it is not possible to use it as 
a virtual host. Verify the suggested values below 
and click OK to continue with the default host
switch. Otherwise click Cancel not to change
the default host.")),
	    // translators: textentry to set the host name
	    `TextEntry (`id ("servername"), _("Server &Name:"), servername),
	    // translators: textentry to set the host IP address
	    `Left( `ComboBox( `id("ip"), `opt(`editable), _("Server &IP address:"), ips ) ),
	    `VSpacing(0.5),
	    `HBox( `PushButton (`id(`ok), `opt(`default), Label::ContinueButton ()),
		`PushButton (`id(`cancel), Label::CancelButton ()) )
	));
	
    UI::SetFocus (`id("servername"));
    UI::ChangeWidget (`id("ip"), `Value, ip);
    
    symbol ret = nil;

    do
    {
	ret = (symbol)UI::UserInput ();
	if (ret == `cancel)
	{
	    break;
	}
	
	// it must be `ok
	if (! validate_servername("servername",nil,nil))
	{
	    continue;
	}

	servername = (string)UI::QueryWidget (`id("servername"), `Value);
	
	if (! validate_serverip("ip",nil,nil))
	{
	    continue;
	}
	ip = (string)UI::QueryWidget (`id("ip"), `Value);
	
	break;
	
    } while (ret != nil);
    
    UI::CloseDialog ();
    return ret != `cancel ? $[ "name": servername, "ip" : ip ] : (map<string,string>)nil;
}

symbol HostsHandle (string table, map event)
{
    if ( event["ID"]:nil == `_tp_add )
    {
	return `add;
    }

    else if (event["ID"]:nil == `_tp_edit)
    {
	currenthost = (string)UI::QueryWidget (`_tp_table, `CurrentItem);
	return `edit;
    }
    
    else if (event["ID"]:nil == `set_default)
    {
	string host = (string)UI::QueryWidget (`_tp_table, `CurrentItem);
	
	if (host == "default")
	{
	    // it is already the default host
	    Popup::Message (_("The host is already default.") );
	    return nil;
	}

	y2milestone ("Changing default host to '%1'", host);
	
	list< map<string,any> > defhost_options = YaST::HTTPDData::GetHost("default");
	string servername = get_host_value( "ServerName", defhost_options, "");
	string ip = get_host_value( "HostIP", defhost_options, "");
	if (ip == "" || servername != "")
	{
	    // we must set a new server name and ip for the old default host
	    map res = AskNewInfo (servername, ip);
	    if (res == nil)
	    {
		// cancel the change
		return nil;
	    }
	    
	    defhost_options = set_host_value( "HostIP", defhost_options, res["ip"]:ip);
	    defhost_options = set_host_value( "ServerName", defhost_options, res["name"]:ip);
	}
	
	// move the old default host elsewhere
	YaST::HTTPDData::CreateHost ( ip+"/"+servername, defhost_options );
	// replace the values of the default host by the new one
	YaST::HTTPDData::ModifyHost ("default", YaST::HTTPDData::GetHost(host) );
	// remove the old non-default host
	YaST::HTTPDData::DeleteHost (host);
	
	HttpServer::modified = true;

	TablePopup::TableInit(hosts_widget, table);
    }
    else 
    {
	return TablePopup::TableHandle(hosts_widget, table, event);
    }
    
    return nil;
}

list HostsContents (map descr) {
    return YaST::HTTPDData::GetHostsList ();
}

boolean HostsDelete (any opt_id, string opt_key) {
    if (opt_id == "default")
    {
	// translators: error message - default host cannot be deleted
	Popup::Error (_("Cannot delete the default host."));
	return false;
    }
    // message popup
    if (! Popup::YesNo (_("Delete selected host?")))
	return false;
	
    HttpServer::modified = true;
    return YaST::HTTPDData::DeleteHost ((string)opt_id);
}

global string HostName (string id)
{
    string res = get_host_value ( "ServerName", YaST::HTTPDData::GetHost(id), id );
    // translators: human-readable "default host"
    if (id == "default" && res == "default" ) res = _("Default host");
    return res;
}


global string HostDocumentRootSummary( string key, any id )
{
    return get_host_value ("DocumentRoot", YaST::HTTPDData::GetHost(key), "");
}

global boolean HostIsDefault( any widget, string key )
{
    return key == "default";
}

/******************************************************************************************/

global string summaryGenericList( any key, any id );
global symbol handleHostTable( any key, map event );
global list<string> HostTableContents (map descr);
global void DefaultHostPopupInit (any opt_id, string opt_key);
global void DefaultHostPopupStore (any opt_id, string opt_key);
global string HostTableEntrySummary (string opt_id, string opt_key);
global boolean HostTableEntryDelete (string opt_id, string opt_key);
global string HostId2Key( map desc, string id );
global void initModules (any key);
global symbol handleModules (any key, map event);
global void initListenSettings (any key);
global symbol handleListenSettings (any key, map event);
global void initServiceStatus (any key);
global void storeServiceStatus (any key, map event);
global void initAdaptFirewall (any key);
global void storeAdaptFirewall (any opt_id, map event);
global void DirectoryOptionInit (string key);
global void DirectoryOptionStore (string opt_id, map event);

/**
 * Map of popups for CWM
 */
global map<string,map> popups = $[
	    "ServerName" : $[
		"table" : $[
		    // table cell description
		    "label" : _("Server Name"),
		    "optional" : false,
		],
		"popup" : $[
		    "label"  : _("Server Name"),
		    "widget" : `textentry,
		    "validate_type" : `function,
		    "validate_function" : validate_servername,	    
		],
	    ],
	    "DocumentRoot" : $[
		"table" : $[
		    // table cell description
		    "label" : _("Document Root"),
		    "optional" : false,
		],
		"popup" : $[
		    "widget" : `textentry,
		],
            ],
	    "ServerAdmin" : $[
		"table" : $[
		    // table cell description
		    "label" : _("Server Administrator E-Mail"),
		    "optional" : false,
		],
		"popup" : $[
		    "widget" : `textentry,
		],
            ],
	    "VirtualByName" : $[
		"table" : $[
		    // table cell description
		    "label"  : _("Server Resolution"),
		    "optional" : false,
		],
	    ],
	    "HostIP" : $[
		"table" : $[
		    // table cell description
		    "label"  : _("IP Address"),
		    "optional" : false
		],
	    ],
	    "SSL" : $[
		"table" : $[
		    "handle" : `ssl,
		    "optional" : false,
		]
	    ],
	    "Directory" : $[
		"table" : $[
		    "label" : "Directory",    
		],
		"popup" : $[
		    "widget" : `custom,
		    "custom_widget"	: 
		    `VBox(
			// translators: directory path
			`TextEntry (`id(`path), _("&Path:")),
			`MultiLineEdit (`id(`contents),"")
		    ),
		    "init" : DirectoryOptionInit,
		    "store" : DirectoryOptionStore,
		],
	    ],
	];

define void HostInit (any key);

global map<string, any> hostwidget = (map<string, any>)TablePopup::CreateTableDescr (
	    $["add_delete" : true, 
	      "up_down" : false, 
	      "unique_keys" : false]
	, $[
	    "init" : HttpServerWidgets::HostInit,
	    "handle" : HttpServerWidgets::handleHostTable,
	    "options" : union( (map)SCR::Read (.target.ycp, Directory::datadir + "/all-host-options.ycp"), popups ),
	    "ids" : HttpServerWidgets::HostTableContents,
	    "id2key" : HttpServerWidgets::HostId2Key,
	    "fallback" : $[
		"init" : HttpServerWidgets::DefaultHostPopupInit,
		"store" : HttpServerWidgets::DefaultHostPopupStore,
		"summary" : HttpServerWidgets::HostTableEntrySummary,
	    ],
	    "option_delete" : HttpServerWidgets::HostTableEntryDelete,
	    "add_items" : 
		maplist( string key, any value, (map<string,any>)SCR::Read (.target.ycp, Directory::datadir + "/all-host-options.ycp"), ``(key) ),
	    "help" : HELPS["global_table"]:"",
	]);

define void HostInit (any key) ``{
    TablePopup::TableInit (HttpServerWidgets::hostwidget, key);
}


global map moduleslistwidget = $[
	    "widget" : `custom,
	    "custom_widget" : `VBox (
		`Table (`id (`modules), `header (
		    // table header: module name
		    _("Name"),
		    // table header: module status
		    _("Status")+"    ",
		    // table header: module description
		    _("Description")
		), []),
		`HBox (
		    `PushButton (`id (`toggle),
		    // translators: toggle button label
			_("&Toggle Status") ),
		    `HStretch (),
		    `PushButton (`id (`add_user),
		    // translators: add user-defined module button label
			_("&Add Module") )
		)
	    ),
	    "init" : HttpServerWidgets::initModules,
	    "handle" : HttpServerWidgets::handleModules,
	    "help" : HELPS["modules"]:"",
	];

global map listenwidget = $[
	    "widget" : `custom,
	    "custom_widget" : `VBox (
		// translators: radio button group label
		`Left(`Label( _("Listen on Ports:") ) ),
		`Table (`id (`listen), `header (
		    // table header
		    _("Network Address"),
		    // table header
		    _("Port")
		), []),
		`HBox (
		    `PushButton (`id (`add), `opt (`key_F3),
			Label::AddButton ()),
		    `PushButton (`id (`edit), `opt (`key_F4),
			Label::EditButton ()),
		    `PushButton (`id (`delete), `opt (`key_F5),
			Label::DeleteButton ()),
		    `HStretch ()
		)
	    ),
	    "init" : HttpServerWidgets::initListenSettings,
	    "handle" : HttpServerWidgets::handleListenSettings,
	    "help" : HELPS["listen"]:"",
	];


global symbol handleSSLTable( any key, map event );
global list<string> SSLTableContents (map descr);
global void SSLInit (any key);
global void SSLTypeInit (any widget);
global void SSLTypeStore (any widget);

map<string, map> edit_ssl = $[
    "table" : $[
	"optional" : false,
    ],
    "popup" : $[
	"widget" : `radio_buttons,
	"items" : [
	    // translators: radio button for SSL being disabled
    	    [ "0", _("&No SSL") ],
	    // translators: radio button for SSL being allowed
    	    [ "1", _("SSL &Allowed") ],
	    // translators: radio button for SSL being required
    	    [ "2", _("SSL &Required") ],
	],
	"orientation" : `horizontal,
	"init" : SSLTypeInit,
	"store" : SSLTypeStore,
    ]
];

map<string, any> sslwidget = (map<string, any>)TablePopup::CreateTableDescr (
	    $["add_delete" : true, 
	      "up_down" : false, 
	      "unique_keys" : true]
	, $[
	    "init" : HttpServerWidgets::SSLInit,
	    "handle" : HttpServerWidgets::handleSSLTable,
	    "options" : union( ssl_options, $[ "SSL":edit_ssl ] ),
	    "ids" : HttpServerWidgets::SSLTableContents,
	    "fallback" : $[
		"init" : HttpServerWidgets::DefaultHostPopupInit,
		"store" : HttpServerWidgets::DefaultHostPopupStore,
		"summary" : HttpServerWidgets::HostTableEntrySummary,
	    ],
	    "option_delete" : HttpServerWidgets::HostTableEntryDelete,
	    "add_items" : maplist( string key, any value, ssl_options, ``(key) ),
	    "help" : HELPS["ssl"]:"",
	]);


/**
 * Map of widgets for CWM
 */
global map widgets = $[
	    "server_enable" : $[
		"widget" : `radio_buttons,
		// translator: server enable/disable radio button group
		"label"	 : _("HTTP &Service"),
		"items"	 : [
		    // translators: service status radio button label
		    [ "disabled", _("Disabled") ],
		    // translators: service status radio button label
		    [ "enabled", _("Enabled") ]
		],
		"init"	: HttpServerWidgets::initServiceStatus,
		"store"	 : HttpServerWidgets::storeServiceStatus,
		"handle_events" : [ "enabled", "disabled" ],
		"opt" : [ `notify ],
		"help" : HELPS["server_enable"]:"",
	    ],
	    "firewall_adapt" : $[
		"widget" : `checkbox,
		// translators: checkbox label
		"label"	 : _("Adapt &Firewall"),
		"help"	 : HELPS["firewall_adapt"]:"",
		"init"	: HttpServerWidgets::initAdaptFirewall,
		"store"	 : HttpServerWidgets::storeAdaptFirewall,
	    ],
	    "host" : hostwidget,
	    "modules" : moduleslistwidget,
	    "listen" : listenwidget,
	    "overview_widget" : overview_widget,
	    "hosts"	: hosts_widget,
	    "ssl" : sslwidget,
	];


/******************************** SSL widget ****************************/

global symbol handleSSLTable( any key, map event )
{
    if ( event["ID"]:nil == `generate_certificate )
    {
	// SLES: generate it
	return nil;
    }
    return TablePopup::TableHandle( sslwidget, key, event );
}

global list<string> SSLTableContents (map descr)
{
    // translators: unknown table entry value
    list<string> ret = maplist (map<string, any> option, YaST::HTTPDData::GetHost(currenthost), ``(option["KEY"]:_("<unknown>")));
    
    // filter out unneeded options - only those with SSL are interesting
    ret = filter (string key, ret, ``( issubstring( key, "SSL" )));
    return ret;
}

global void SSLInit (any widget)
{
    TablePopup::TableInit(sslwidget, widget);
}

global void SSLTypeInit (any widget)
{
    // it is a radio button group
    UI::ChangeWidget (`id(widget), `CurrentButton, tostring( get_host_value( "SSL", YaST::HTTPDData::GetHost(currenthost), "0" ) ) );
}


global void SSLTypeStore (any widget)
{
    // it is a radio button group
    YaST::HTTPDData::ModifyHost( currenthost, set_host_value ("SSL", YaST::HTTPDData::GetHost(currenthost), UI::QueryWidget( `id(widget), `CurrentButton ) ) );
    HttpServer::modified = true;
}


/******************************** Listen popup ****************************/

/**
 * Convert a Listen string to an item for table. Splits by the colon.
 *
 * @param arg		the Listen map
 * @param id		the id of this item
 * @return term		term for the table
 */
global define term listen2item( map<string,any> arg, integer id ) ``{

    string address = arg["ADDRESS"]: _("All Addresses");
    if (address == "") address = _("All Addresses");
    string port = arg["PORT"]:"80";
    
    return `item( `id(id), address, port );
}

/**
 * Convert a Listen string to an item for table. Splits by the colon.
 *
 * @param network	network address
 * @param port		port number
 * @return string 	Listen value
 */
define string item2listen( string network, string port ) ``{

    if( network == _("All Addresses") ) network = "";
    
    if( size(network) > 0 ) port = network +":"+ port ;
    
    return port;
}

    /**
     * Show a popup for editing Listen statement.
     *
     * @param network 	initial value for the network part of the statement
     *                  If empty or _("All Addresses"), considered for all Listen for all interfaces.
     * @param port	initial value for a port number
     * @return string	the new Listen statement or nil if Cancel was pressed
     */
    define map<string,string> AskListen( string network, string port ) ``{
	// translators: all network addresses Listen type
	boolean adr_type = ( network == _("All Addresses") || network == "" );
	if( port == nil ) port = "";
	
	// translators: Listen type for all addresses;
	string aa =  _("All Addresses");
	
	list ips = union( [ aa ], maplist( string ip, string dev, HttpServer::ip2device, ``( ip ) ) );

	UI::OpenDialog( `VBox(
	    // translators: text entry label
	    `TextEntry( `id(`port), _("&Port:"), port ),
	    // translators: combo box label for list of configured IPs
	    `Left( `ComboBox( `id("address"), `opt( `editable ), _("Network &Address:"), ips ) ),
	    `VSpacing(),
	    `HBox( 
		`PushButton( `id(`ok), Label::OKButton() ),
		`PushButton( `id(`cancel), Label::CancelButton() )
	     )
	));
	
	if( !adr_type ) {
	    UI::ChangeWidget( `id( "address" ), `Value, network );
	}
	
	symbol ret = nil;
	map<string,string> res = $[];
	do {

	    ret = (symbol) UI::UserInput();
	    
	    if( ret == `ok ) {
		res["ADDRESS"] = (string)UI::QueryWidget( `id("address"), `Value );
		res["PORT"] = (string)UI::QueryWidget( `id(`port), `Value );
		if ( res["ADDRESS"]:nil == aa ) 
		{
		    // on all addresses, cleanup the value
		    res["ADDRESS"] = "";
		}
		else
		{
		    // validate
		    if (! validate_serverip ("address", nil, nil) )
		    {
			ret = nil;
			continue;
		    }
		}
		
		// validation
		if( ! regexpmatch( res["PORT"]:"", "^[ \t]*[0-9]+[ \t]*$" ) ) {
		    // translators: error message when validating Listen statement
		    Popup::Error( _("Invalid port number.") );
		    ret = nil;
		    continue;
		}
		
	    }
	} while( ret != `ok && ret != `cancel );
	
	if( ret == `cancel ) res = nil;
	
	UI::CloseDialog();
	
	return res;
    }	
    
// *************************************** log popups **************************

    /**
      * Handle function of the access log button (the first defined access log file)
      * @param key any key of the widget
      * @param event map event that occured
      * @return value for wizard sequencer, always nil
      */
    global define symbol showAccessLogPopup (any key, map event) {
	string log = (string) select( YaST::HTTPDData::GetAccessLogFiles( [currenthost] ), 0, "/var/log/apache2/access_log" );

	// strip the log format, if present
	log = select( splitstring( log, " " ), 0, "/var/log/apache2/access_log" );

	LogView::Display ($[
	    "command" : sformat( "tail -f %1 -n 100 | /usr/sbin/logresolve2", log ),
	    "save" : true,
	    "actions" : [
		// menubutton entry, try to keep short
		[ _("&Reload HTTP Server"),
		    ``{SCR::Execute (.target.bash,
			"rcapache2 reload");}],
		// menubutton entry, try to keep short
		[ _("Save Settings and Re&start HTTP Server"),
		    HttpServer::Write, true ],
	    ],
	]);
	return nil;
    }

    /**
      * Handle function of the error log button
      * @param key any key of the widget
      * @param event map event that occured
      * @return value for wizard sequencer, always nil
      */
    global define symbol showErrorLogPopup (any key, map event) ``{
	string log = get_host_value( "ErrorLog", YaST::HTTPDData::GetHost(currenthost), "/var/log/apache2/error_log");
	
	// strip the log format, if present
	log = select( splitstring( log, " " ), 0, "/var/log/apache2/error_log" );

	LogView::Display ($[
	    "command" : sformat( "tail -f -n +100  %1 | /usr/sbin/logresolve2", log ),
	    "save" : true,
	    "actions" : [
		// menubutton entry, try to keep short
		[ _("Reload HTTP Server"),
		    ``{SCR::Execute (.target.bash,
			"rcapache2 reload");}],
		// menubutton entry, try to keep short
		[ _("Save Settings and Restart HTTP Server"),
		    ``{HttpServer::Write();} ],
	    ],
	]);
	return nil;
    }

// ************************************ default host table ********************

    global string HostId2Key( map desc, string id )
    {
	if (regexpmatch (id, directory_param_regexp) )
	{
	    return "Directory";
	}
	else return id;
    }

    global void DirectoryOptionInit (string opt_id)
    {
	if (opt_id == nil)
	{
	    // new option
	    return;
	}
	string dirname = regexpsub (opt_id, directory_param_regexp, "\\1");

	// lookup the _SECTION map
	map<string, any> section = nil;
	foreach ( map<string, any> opt, YaST::HTTPDData::GetHost(currenthost), ``{
	    if (opt["KEY"]:nil == "_SECTION" 
		&& opt["SECTIONNAME"]:nil == "Directory"
		&& opt["SECTIONPARAM"]:nil == "\""+dirname+"\""
	    ) 
	    {
		section = opt;
		break;
	    }
	});
	
	if (section == nil)
	{
	    y2error ("Corresponding section not found for %1", dirname);
	    return;
	}
	
	// create a textual representation of the section
	string text = "";
	foreach (map<string,any> opt, section ["VALUE"]:[], ``{
	    if (opt["KEY"]:nil != "_SECTION")
	    {
		text = text + opt["KEY"]:"" + " " + opt["VALUE"]:"" + "\n";
	    }
	    // FIXME: subsections
	});
	
	UI::ChangeWidget( `id(`path), `Value, dirname );
	UI::ChangeWidget( `id(`contents), `Value, text );
	UI::SetFocus (`id(`path) );
    }
    
    global void DirectoryOptionStore (string opt_id, map event)
    {
	string dirname = regexpsub (opt_id, directory_param_regexp, "\\1");
	if (size (dirname) == 0)
	{
	    y2error ("Invalid directory option: %1", opt_id);
	    return;
	}
	
	// FIXME: fix path change
	string dir = (string)UI::QueryWidget (`id(`path), `Value);
	// ensure \" around dirname
	dir = regexpsub (dir, "\"?([^\"]+)\"?", "\"\\1\"");
	
	string text = (string)UI::QueryWidget (`id(`contents), `Value);
	
	map<string,any> new_section = YaST::HTTPDData::ParseDirOption(dir+"\n"+text);
	y2milestone ("Updated section: %1", new_section );

	list< map<string, any> > host = YaST::HTTPDData::GetHost(currenthost);
	integer index = 0;

	// replace the old section
	foreach ( map<string, any> opt, host , ``{
	    if (opt["KEY"]:nil == "_SECTION" 
		&& opt["SECTIONNAME"]:nil == "Directory"
		&& opt["SECTIONPARAM"]:nil == "\""+dirname+"\""
	    ) 
	    {
		break;
	    }
	    index = index + 1;
	});
	
	if (index == size (host) )
	{
	    // add the option
	    host = add (host, new_section);
	}
	else
	{
	    // replace the option
	    host[index] = new_section;
	}

	YaST::HTTPDData::ModifyHost (currenthost, host);
	
	update_contents = true;

	return;
    }
    
    /**
      * Function for getting contents of the default host table
      * @param descr map description map of the table
      * @return list of items for the table
      */
    global define list<string> HostTableContents (map descr) ``{
    
	list< map<string, any> > host = YaST::HTTPDData::GetHost(currenthost);
	y2internal ("Host: %1", host );
	list<string> ret = maplist (map<string, any> option, host, ``{
	    string key = option["KEY"]: "unknown";
	    if ( ! contains( ["_SECTION", currenthost == "default" ? "HostIP" : "" ], key ) && ! haskey( ssl_options, key ) )
	    {
		return key;
	    }
	    else if ( key == "_SECTION" && option["SECTIONNAME"]:"" == "Directory" )
	    {
		return "Directory " + option["SECTIONPARAM"]:"";
	    }
	    else return "";
	});
	
	// filter out empty entries
	ret = filter (string key, ret, ``( size(key) > 0 ));

	// required entries
	ret = (list<string>)union (["ServerName", "ServerAdmin" ], ret);
	return ret;
    }
    
    /**
      * Delete function of the global table
      * @param opt_id any option id of selected option
      * @param opt_key any option key of selected option
      * @return boolean true if was really deleted
      */
    global define boolean HostTableEntryDelete (string opt_id, string opt_key) ``{
	// message popup
	if (! Popup::YesNo (_("Delete selected entry?")))
	    return false;
	list< map<string, any> > options = YaST::HTTPDData::GetHost (currenthost);
	
	if ( regexpmatch (opt_id, directory_param_regexp) )
	{
	    // it's directory, handle differently
	    string dirname = regexpsub (opt_id, directory_param_regexp, "\"\\1\"");

	    YaST::HTTPDData::ModifyHost (currenthost
		, filter (map<string,any> opt, options
		, ``(opt["KEY"]:nil != "_SECTION" 
			|| opt["SECTIONNAME"]:nil != "Directory"
			|| opt["SECTIONPARAM"]:nil != dirname )
	    ));
	}
	else
	{
	    YaST::HTTPDData::ModifyHost (currenthost, filter (map<string,any> opt, options, ``(opt_id != opt["KEY"]:"")));
	}

	HttpServer::modified = true;
	return true;
    }

    /**
     *  Handler for editing default host. Handles additional buttons, like logs and modules.
     *  Rest is passed to TablePopup::TableHandle.
     *
     *  @param key	the key modified
     *  @param event	event description
     *  @return symbol 	the result of the handling
     */
    global define symbol handleHostTable( any key, map event ) ``{
	// handle menu button entries
	if( event["ID"]:nil == `show_access_log ) {
	    return showAccessLogPopup( key, event );
	}
	else if( event["ID"]:nil == `show_error_log ) {
	    return showErrorLogPopup( key, event );
	}

	// default handling
	symbol res = TablePopup::TableHandle( hostwidget, key, event );
	if (update_contents)
	{
	    update_contents = false;
	    TablePopup::TableInit( hostwidget, key);
	}
	return res;
    }

    /**
      * Fallback initialization function of a table entry / popup
      * @param opt_id any option id
      * @param opt_key any option key
      */
    global define void DefaultHostPopupInit (any opt_id, string opt_key) ``{
	UI::ChangeWidget (`id (opt_key), `Value,
	    get_host_value( opt_key, YaST::HTTPDData::GetHost(currenthost), "") );
    }

    /**
      * Fallback store function of a table entry / popup
      * @param opt_id any option id
      * @param opt_key any option key
      */
    global define void DefaultHostPopupStore (any opt_id, string opt_key) ``{
	list< map<string, any> >options = YaST::HTTPDData::GetHost (currenthost);
	options = set_host_value( opt_key, options, UI::QueryWidget (`id (opt_key), `Value) );
	YaST::HTTPDData::ModifyHost (currenthost, options);
	HttpServer::modified = true;
    }

    /**
      * Fallback summary function of a table entry / popup
      * @param opt_id any option id
      * @param opt_key any option key
      * @return string table entry summary
      */
    global define string HostTableEntrySummary (string opt_id, string opt_key) ``{
	string res = get_host_value( opt_key, YaST::HTTPDData::GetHost(currenthost), "");
	if (opt_key == "SSL")
	{
	    if (res == "0") 
	    {
		// translators: table entry text for SSL being disabled
		res = _("No SSL");
	    }
	    else if (res == "1")
	    {
		// translators: table entry text for SSL being allowed for each request
		res = _("Enabled");
	    }
	    else if (res == "2")
	    {
		// translators: table entry text for SSL being required for each request
		res = _("Required");
	    }
	}
	else if (opt_key == "VirtualByName")
	{
	    if (res == "0")
	    {
		// translators: table entry text for name-based vhosts
		res = _("Resolution via HTTP Headers");
	    }
	    else 
	    {
		// translators: table entry text for IP-based vhosts
		res = _("Resolution via IP Address Used");
	    }
	}
	else if (regexpmatch (opt_id, directory_param_regexp))
	{
	    res = regexpsub (opt_id, directory_param_regexp, "\\1");
	}
	return res;
    }


// ************************************ modules list ***************************

    /**
      * Initialize function of a widget
      * @param key any widget key of widget that is processed
      */
    global define void initModules (any key) ``{
	list< map<string,any> > known = YaST::HTTPDData::GetKnownModules();
	list<string> modules = YaST::HTTPDData::GetModuleList();
	integer index = -1;
	
	list<term> items = maplist (map<string,any> mod, known , ``{
	    index = index + 1;
	    // translators: server module status unknown
	    string name = mod["name"]:_("unknown");
	    // translators: server module status
	    return `item (`id (index), name, contains( modules, name) ? _("Enabled") 
		// translators: server module status
		: _("Disabled"), mod["summary"]:"" );
	});
	UI::ChangeWidget (`id (`modules), `Items, items);
	UI::SetFocus (`id (`modules));
    }

    /**
      * Handle function of a widget
      * @param key any widget key of widget that is processed
      * @param event any event that occured
      * @return symbol symbol for WS or nil
      */
    global define symbol handleModules (any key, map event) ``{
	UI::SetFocus (`id (`modules));
	integer current = (integer) UI::QueryWidget (`id (`modules), `CurrentItem);
        if (event["ID"]:nil == `toggle)
        {
	    integer ci = (integer) UI::QueryWidget( `id( `modules ), `CurrentItem );
	    string status = (string) select( (term) UI::QueryWidget( `id(`modules), `Item(ci) ), 2, _("Enabled") );
	    string name = (string) select( (term) UI::QueryWidget( `id(`modules), `Item(ci) ), 1, nil );	    
	    y2debug( "Status of module: %1", status );
	    if( status == _("Enabled") ) status = _("Disabled");
	    else status = _("Enabled");
	    UI::ChangeWidget( `id( `modules ), `Item( ci , 1 ) , status );
	    YaST::HTTPDData::ModifyModuleList ([name], status == _("Enabled"));
	    HttpServer::modified = true;
        }
	else if (event["ID"]:nil == `add_user)
        {
	   UI::OpenDialog(
            `VBox(
		// translators: text entry label for adding a user-defined module
                `TextEntry(`id(`mod), _("New Module &Name:")),
                `HBox(
                    `PushButton(`id(`ok), `opt(`default), Label::OKButton() ),
                    `PushButton(`id(`cancel), Label::CancelButton() )
            	    )
        	)
    	    );
	    
	    UI::SetFocus( `id( `mod ) );

	    list<string> existing = maplist (term item, (list<term>) UI::QueryWidget( `id(`modules), `Items )
		, ``(item[1]:""));

	    symbol ret = (symbol) UI::UserInput();
	    
	    if( ret == `ok ) {
		string mod = String::CutBlanks( (string) UI::QueryWidget( `id(`mod), `Value ) );
		if( mod == "" ) {
		    // translators: error message
		    Report::Error( _("A name for the module to add is required.") );
		} else if( contains( existing, mod )  ) {
		    // translators: error message
		    Report::Error( _("The module is already in the list.") );
		} else {
		    YaST::HTTPDData::ModifyModuleList( [mod], true );
		    HttpServerWidgets::initModules(nil);
		    HttpServer::modified = true;
		}
	    }
	    UI::CloseDialog();
        }

    }

// ************************************ listen settings ************************

    /**
      * Initialize function of a widget
      * @param key any widget key of widget that is processed
      */
    global define void initListenSettings (any key) ``{

	integer id = -1;
	list< map<string,any> > listen = YaST::HTTPDData::GetCurrentListen();
	y2error ("Listen: %1", listen);
	list<term> items = maplist( map<string,any> litem, listen, ``{ id = id+1; return listen2item(litem, id); } );
	UI::ChangeWidget (`id (`listen), `Items, items);
	
	// enable/disable buttons - at least single Listen must be present
	UI::ChangeWidget (`id (`delete), `Enabled, size( listen ) > 1 );
	
	// set focus
	UI::SetFocus (`id (`listen));
    }

    /**
      * Handle function of a widget
      * @param key any widget key of widget that is processed
      * @param event map event that occured
      * @return symbol symbol for WS or nil
      */
    global define symbol handleListenSettings (any key, map event) ``{
	UI::SetFocus (`id (`listen));
	integer current = (integer) UI::QueryWidget (`id (`listen), `CurrentItem);
	term currentitem = (term) UI::QueryWidget( `id(`listen), `Item(current) );
	string network = (string) currentitem[1]:nil;
	// translators: all network addresses Listen type
	if( network == _("All Addresses") ) network = "";
	string port = select(currentitem, 2, "");

        if (event["ID"]:nil == `add)
        {
	    // translators: all network addresses Listen type
	    map<string,string> res = AskListen( _("All Addresses"), "" );
	    if( res != nil ) {
		if (false) // FIXME: CreateListen error reporting
		{
		    // translators: error message for adding a new Listen statement
		    Popup::Error( sformat(_("The entry '%1' already exists."), res) );
		} 
		else
		{
		    YaST::HTTPDData::CreateListen( tointeger(res["PORT"]:"80"), tointeger(res["PORT"]:"80"),
			res["ADDRESS"]:"" );
		    HttpServer::modified = true;
		}
	    }
        }
	else if( event["ID"]:nil == `delete )
	{
	    boolean validate = size( YaST::HTTPDData::GetCurrentListen() ) != 0;

	    y2debug( "Validation result: %1", validate );
	
	    if( !validate ) {
		// translators: error message
		Popup::Error(_("The list of the ports to which the server should
listen cannot be empty.") );
	    return nil;
	    }

	    // remove the entry
	    YaST::HTTPDData::DeleteListen( tointeger(port), tointeger(port), network );
	    HttpServer::modified = true;
	}
	else if( event["ID"]:nil == `edit )
	{
	    map<string,string> res = AskListen( network, port );
	    if( res != nil ) {
		// remove the old one
		YaST::HTTPDData::DeleteListen( tointeger(port), tointeger(port),
			network );
		// create the new one
		YaST::HTTPDData::CreateListen( tointeger(res["PORT"]:"80"), tointeger(res["PORT"]:"80"),
			res["ADDRESS"]:"" );
		HttpServer::modified = true;
	    }
	}
	
	initListenSettings(nil);
    }

    
// ************************************ server status ***********************

    /**
      * Initialize function of a widget
      * @param key any widget key of widget that is processed
      */
    global define void initServiceStatus (any key) ``{
	if( YaST::HTTPDData::GetService()  ) {
	    UI::ChangeWidget (`id ("enabled"), `Value, true);
	}
	else 
	{
	    UI::ChangeWidget (`id ("disabled"), `Value, true);
	}
    }

    /**
      * Store function of a widget
      * @param key any widget key of widget that is processed
      * @param event map event that occured
      */
    global define void storeServiceStatus (any key, map event) ``{
	YaST::HTTPDData::ModifyService( (boolean) UI::QueryWidget ( `id("enabled"), `Value ) );
	HttpServer::modified = true;
    }

// ************************************ Adapt firewall widget ********************

    /**
      * Initialization function for firewall adapting
      * @param key any option key to be initialized
      */
    global define void initAdaptFirewall (any key) ``{
	if( Service::Enabled( "SuSEfirewall2_final" ) ) {
	    UI::ChangeWidget (`id (key), `Value, HttpServer::firewall);
	    UI::ChangeWidget (`id (key), `Enabled, true );
	} else {
	    // disable the widget
	    UI::ChangeWidget (`id (key), `Enabled, false );
	}
    }

    /**
      * Store function for firewall adapting
      * @param opt_id any option id
      * @param event map event description
      */
    global define void storeAdaptFirewall (any opt_id, map event) ``{
	if( HttpServer::firewall_started ) {
	    HttpServer::firewall = (boolean)UI::QueryWidget (`id (opt_id), `Value);
	    HttpServer::modified = true;
	}
    }

/* EOF */
}

