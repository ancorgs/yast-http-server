/**
 * File:	modules/HttpServer.ycp
 * Package:	Configuration of http-server
 * Summary:	Data for configuration of http-server, input and output functions.
 * Authors:	Stanislav Visnovsky <visnov@suse.cz>
 *
 * $Id$
 *
 * Representation of the configuration of http-server.
 * Input and output routines.
 */

{

module "HttpServer";
textdomain "http-server";

import "HTTPDData";
import "NetworkDevices";
import "Progress";
import "Report";
import "Require";
import "Service";
import "Summary";

/**
 * Abort function
 * return boolean return true if abort
 */
global block<boolean> AbortFunction = nil;

/**
 * Required packages
 */
global list<string> required_packages = ["apache2"];

/**
 * Data was modified?
 */
global boolean modified = false;

global boolean configured = false;

global boolean proposal_valid = false;

/**
 * Write only, used during autoinstallation.
 * Don't run services and SuSEconfig, it's all done at one place.
 */
global boolean write_only = false;


/**
 * Data was modified?
 * @return true if modified
 */
global define boolean Modified() ``{
    y2debug("modified=%1",modified);
    return modified;
};

include "http-server/routines.ycp";

/**
 * HTTP server settings
 */
global map<string,any> settings = $[];

global define map<string,any> Settings ()
{
    return settings;
}

/**
 * List of status of modules modified
 */
global list<string> modules_modified = [];

/**
 * Mapping of IPs to network devices
 */
global map<string,string> ip2device = $[];

/**
 * List of maps $[ "port": port, "interface": "all" | "eth0", ... ] containing
 * description of listen statement already configured in firewall. Read in
 * Read, used in Write.
 */
global list< map<string,string> > listen4firewall = [];

/**
 * Read all http-server settings
 * @return true on success
 */
global define boolean Read() ``{

    /* HttpServer read dialog caption */
    string caption = _("Initializing HTTP Server Configuration");

    integer steps = 3;

    // We do not set help text here, because it was set outside
    Progress::New( caption, " ", steps, [
	    // translators: progress stage
	    _("Check the environment"),
	    // translators: progress stage
	    _("Read Apache2 configuration"),
	    // translators: progress stage
	    _("Read network configuration")

	], [
	    // translators: progress step
	    _("Checking the environment..."),
	    // translators: progress step
	    _("Reading Apache2 configuration..."),
	    // translators: progress step
	    _("Reading network configuration..."),
	    // translators: progress finished
	    _("Finished")
	],
	""
    );

    // check the environment
    if(Abort()) return false;
    Progress::NextStep();

    // check httpd.conf
    if( SCR::Read( .target.lstat, "/etc/apache2/httpd.conf" ) == $[] ) {
	// translators: error message, %1 is the file name of expected configuration file
	Report::Error( sformat( _("The configuration file '%1' does not exist."), "/etc/apache2/httpd.conf" )  );
	return false;
    }

    // check sysconfig
    if( SCR::Read( .target.lstat, "/etc/sysconfig/apache2" ) == $[] ) {
	if( SCR::Execute( .target.bash, "cp /var/adm/fillup-templates/sysconfig.apache2 /etc/sysconfig/apache2" )
	    != 0 ) {
	// translators:: error message
	    Report::Error( sformat( _("Cannot create sysconfig file '%1'."), "/etc/sysconfig/apache2" ) );
	    return false;
	}
    }

    // check listen.conf
    if( SCR::Read( .target.lstat, "/etc/apache2/listen.conf" ) == $[] ) {
	// translators: warning message, %1 is the file name of expected configuration file
	Report::Warning( sformat( _("The configuration file '%1' does not exist."), "/etc/apache2/listen.conf" )  );
	// create empty file
	if( ! SCR::Write( .target.string, "/etc/apache2/listen.conf", "" ) )
	{
	// translators:: error message
	    Report::Error( sformat( _("Cannot create the file '%1'."), "/etc/apache2/listen.conf" ) );
	    return false;
	}
    }

    // read current settings from httpd.conf and sysconfig
    Progress::NextStage();
    
    // read hosts
    HTTPDData::ReadHosts();
    HTTPDData::ReadListen();
    HTTPDData::ReadModules();
    HTTPDData::ReadService();
    
    Progress::NextStage();

    // read current settings for firewall and network
    Progress::off();
    NetworkDevices::Read();

    // generate the map: static IP -> device
    ip2device = $[];
    list<string> devs = NetworkDevices::Locate("BOOTPROTO", "static");
    foreach(string dev, devs, {
	string ip = NetworkDevices::GetValue(dev, "IPADDR");
	if(ip != nil && ip != "") ip2device[ip] = dev;
    });

    y2milestone ("Mapping of IP addresses and network devices: %1", ip2device);    

    // generate the map of our settings in firewall
    listen4firewall = maplist( map<string,string> l, settings["Listen"]:[], ``{
	if( l["ADDRESS"]: nil != nil ) {
	    string ni = ip2device["ADDRESS"]:"";
	    if( ni != "" ) {
		return $[ "port": l["PORT"]:"80", "interface": ni ];
	    } else {
		return $[ "port": l["PORT"]:"80", "interface": "all" ];
	    }
	}
    });
    Progress::on();

    // translators: progress step
    ProgressNextStage(_("Finished"));

    if(Abort()) return false;
    modified = false;

    configured = true;

    return true;
}

/**
 * Write all http-server settings
 * @return true on success
 */
global define boolean Write() ``{

    /* HttpServer read dialog caption */
    string caption = _("Saving HTTP Server Configuration");

    integer steps = 4;

    // We do not set help text here, because it was set outside
    Progress::New(caption, " ", steps, [
	    // translators: progress stage 1/4
	    _("Write the Apache2 settings"),
	    // translators: progress stage 2/4
	    settings[ "settings", "firewall"]:false ?_("Modify firewall") :
		// translators: progress stage 2/4
		_("Modify firewall (skipped)"),
	    // translators: progress stage 3/4
	    _("Run SuSEconfig"),
	    settings["settings", "enabled"]:false ?
		// translators: progress stage 4/4
		_("Enable Apache2 service")
		// translators: progress stage 4/4
		: _("Disable Apache2 service")
	], [
	    // translators: progress step 1/4
	    _("Writing the settings..."),
	    // translators: progress step 2/4
	    settings[ "settings", "firewall"]:false ?_("Modifying firewall...") :
		// translators: progress step 2/4
		_("Skipping firewall modification..."),
	    // translators: progress step 3/4
	    _("Running SuSEconfig..."),
	    settings["settings", "enabled"]:false ?
		// translators: progress step 4/4
		_("Enabling Apache2 service...")
		// translators: progress step 4/4
		: _("Disabling Apache2 service..."),
	    // translators: progress finished
	    _("Finished")
	],
	""
    );

    // write Apache2 settings

    list<string> rpms = HTTPDData::GetModulePackages();

    // install required RPMs for modules
    // TODO: php4 does not work with thread-based apache2 config
    Require::RequireAndConflictTarget( rpms, [], _("The enabled modules require
installation of some of these additional packages:
%1
Install them now?
") );

    // write httpd.conf

    // write hosts
    HTTPDData::WriteHosts ();
    HTTPDData::WriteListen ();
    HTTPDData::WriteModuleList ();
    
#	Report::Error( sformat(_("Cannot write '%1'."), "/etc/apache2/listen.conf" ) );

    Progress::NextStage();

    // modify firewall
    if( settings["settings", "firewall"]: false && settings["settings", "firewall_started"]:false ) {
    
	// FIXME: adapt firewall settings

	// delete all our firewall settings
//	foreach( map listen, listen4firewall, ``{
//	    SuSEFirewall::RemoveService( listen["port"]:"www", "TCP", listen["interface"]:"all" );
//	});

	// setup the new firewall settings
//	y2debug( "Writing Listen settings to firewall: %1", settings["Listen"]:[] );
//	foreach( map<string,string> l, settings["Listen"]:[], ``{
	    // FIXME: interface handling
//	    SuSEFirewall::AddService( l["PORT"]:"www", "TCP", l["interface"]:"all" );
//	});

	Progress::off();
//	SuSEFirewall::Write();
	Progress::on();
    }

    Progress::NextStage();

    // in autoyast, quit here
    // Wrong, service still has to be enabled...
    // if( write_only ) return true;

    // run SuSEconfig
	if (!write_only) {
    if( SCR::Execute( .target.bash, "/sbin/SuSEconfig --module apache2" ) != 0 ) {
	// translators: error message
	Report::Error(_("SuSEconfig script failed!") );
    }
	}

    Progress::NextStage();
    
    if( ! HTTPDData::WriteService(write_only) )
    {
	// translators: error message
	Report::Error( sformat( _("Cannot adjust '%1' service."), "apache2" ) );
    }

    // translators: progress finished
    ProgressNextStage(_("Finished"));

    if(Abort()) return false;
    return true;
}

map<string,any> find_known_module (list< map<string,any> > known_modules, string mod)
{
    map<string,any> res = nil;
    foreach( map<string,any> i, known_modules, ``{
	if (i["name"]:"" == mod)
	{
	    res = i;
	    break;
	}
    });
    
    return res;
}

/**
 * Get all http-server settings from the first parameter
 * (For use by autoinstallation.)
 * @param s The YCP map to be imported
 * @return boolean True on success
 */
global define boolean Import (map s) ``{
    string version = s["version"]:"unknown";
    
    // setup modules
    list <map <string,any> > known_modules = HTTPDData::GetKnownModules();
    list <map <string,any> > modules = s["modules"]: [];
    foreach (map<string,any> desc, modules, ``{
	string mod = desc["name"]:"";
	
	if ( size(mod) == 0 )
	{
	    Report::Warning( _("Module description does not have a name specified, ignoring.") );
	    continue;
	}

	string change_string = desc["change"]:"nochange";

	// get the default
	boolean default = (boolean)desc["default"]:nil;
	
	if (change_string != "nochange")
	{
	    if (! contains ([ "enable", "disable" ], change_string  ) )
	    {
		Report::Warning (sformat(_("Unknown change of a module for autoinstallation: %1"), change_string));
		continue;
	    }
	    
	    // just change the status
	    HTTPDData::ModifyModuleList( [mod], change_string == "enable" );
	}
	else
	{
	    // check against the current default
	    if (default != nil && lookup( find_known_module(known_modules, mod), "default", nil) != default)
	    {
		Report::Warning (sformat(_("Default value for module %1 does not match.
This can cause inconsistent module configuration."), mod));
	    }
	}	
    });
    
    // setup listen
    list < map<string, any> > listen = s["Listen"]:[];
    foreach (map<string, any> l, listen, ``{ 
	if ( !haskey(l, "PORT") )
	{
	    Report::Error (_("Listen statement without port found."));
	}
	else
	{
	    HTTPDData::CreateListen(l["PORT"]:0, l["PORT"]:0, l["ADDRESS"]:"" ); 
	}
    });

    // setup hosts
    map <string, list<map<string, any> > > hosts = s["hosts"]:$[];
    foreach (string host, list<map<string, any> > desc, hosts, ``{ HTTPDData::CreateHost(host,desc); }); // check host name
    
    // setup service
    if (haskey( s, "service" ))
    {
	HTTPDData::ModifyService (s["service"]:false);
    }
    
    // setup firewall
    if (haskey( s, "firewall" ))
    {
	settings["firewall"] = s["firewal"]:false;
    }

    modified = false;
    configured = true;

    return true;
}

/**
 * Dump the http-server settings to a single map
 * (For use by autoinstallation.)
 * @return map Dumped settings (later acceptable by Import ())
 */
global define map Export () ``{
    list < map <string,any> > known_modules = HTTPDData::GetKnownModules();
    list <string> enabled_modules = HTTPDData::GetModuleList();

    // walk over the known modules    
    list <map <string,any> > modules = maplist (map<string, any> desc, known_modules, ``(
	$[  "name" : desc["name"]:"", 
	    "change" : desc["default"]:nil == true ? 
	    // default is true
	    (
		contains (enabled_modules, desc["name"]:"") ? "nochange" : "enable"
	    )
	    :
	    // default is false
	    (
		contains (enabled_modules, desc["name"]:"") ? "disable" : "nochange"
	    ),
	    "default" : desc["default"]: false
	] ));
    // store the user defined ones
    foreach (string mod, enabled_modules, ``{
	if( find_known_module(known_modules, mod) != nil )
	{
	    // user-defined
	    modules = add (modules, $[
		"name" : mod,
		"change" : "enable",
		"userdefined" : true
	    ]);
	}
    });
    
    // hosts
    map <string, list< map<string,any> > > hosts = listmap (string host, HTTPDData::GetHostsList(), ``(
	$[ host : HTTPDData::GetHost(host) ]
    ));

    map result = $[
	"version" : "2.9",
	"modules": modules,
	"hosts" : hosts,
	"Listen": HTTPDData::GetCurrentListen(),
	"service" : HTTPDData::GetService (),
	"firewall" : settings["firewall"]:false,
    ];

    configured = true;

    return result;
}

/**
 * Create a textual summary for the current configuration
 * @return summary of the current configuration
 */
global define list Summary() ``{

    string nc = Summary::NotConfigured ();

    string summary = "";

    if( configured ) {
        // summary item: an option is turned on
        if( settings["settings", "enabled"]:false )
	    // translators: autoyast summary text, server status
            summary = Summary::AddLine(summary, _("Apache2 server is <i>enabled</i>") );
        else
	    // translators: autoyast summary text, server status
            summary = Summary::AddLine(summary, _("Apache2 server is <i>disabled</i>") );
    } else {
        summary = Summary::AddLine(summary, nc );
    }

    return [ summary, [] ];
}

/**
 * Return required packages for auto-installation
 * @return map of packages to be installed and to be removed
 */
global define map AutoPackages() ``{
       if( !Require::IsAnyPackageInstalledTarget( ["apache2-prefork", "apache2-metuxmpm", "apache2-worker"] ) ) {
           // add a default MPM - prefork because of the PHP4 compatibility
        required_packages = (list<string>)union (required_packages, ["apache2-prefork"] );
       }

       return ($["install": required_packages, "remove": []]);

}

/* EOF */
}
