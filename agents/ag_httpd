#!/usr/bin/perl -w
#
# $Id$
# Author: Martin Vidner <mvidner@suse.cz>
#         Stanislav Visnovsky <visnov@suse.cz>
#

# A trivial agent for reading/modifying Apache2 httpd.conf file
# supports only Listen on top-level

use ycp;
use strict;
use File::Temp;

# known values which can be read
my @known_values = qw( Listen CustomLog ErrorLog );

#
# MAIN cycle
#

# read the agent arguments
$_ = <STDIN>;

my $httpd_conf = "";
my $init = $_;
if( $init =~ m/^\"?([^\"]+)\"?$/ )
{
   $httpd_conf = $1;
}

y2debug( $httpd_conf );

if( not open( CONF, $httpd_conf ) ) {
    die "Cannot open configuration file '$httpd_conf'";
}

ycp::Return (undef);

# read the configuration

my @listen = ();
my @custom_log = ();
my $error_log = "";
my $line = "";
my $new_listen = "";
my $size = "";

my @section_stack = ();
my $stack_size = 0;

while( $line = <CONF> ) {
    chomp( $line );
    
    # section start
    if( $line =~ /^\s*<([^\/\s]+).*>/ ) {
	y2debug( "Pushing $1" );
	push( @section_stack, $1 );
	$stack_size = $stack_size+1;
    }
    
    # section end
    if( $line =~ /^\s*<\/([^\s]+).*>/ ) {
	my $found_sect = $1;
	my $exp_sect = pop( @section_stack );
	y2debug( "Popped $1" );
	if( $found_sect ne $exp_sect ) {
	    y2error( "Non-matching section: found '$found_sect', expected '$exp_sect'" );
	    push( @section_stack, $exp_sect );
	} else {
	    $stack_size = $stack_size-1;
	}
    }
    
    # only top-level values
    if( $stack_size == 0 ) {
	if( $line =~ /^[ \t]*Listen[ \t]+([^ \t]+)/ ) {
	    push( @listen, $1 );
	}
    
	if( $line =~ /^[ \t]*CustomLog[ \t]+([^ \t]+)/ ) {
	    push( @custom_log, $1 );
	}

	if( $line =~ /^[ \t]*ErrorLog[ \t]+([^ \t]+)/ ) {
	    $error_log = $1;
	    y2debug( "Found error log $error_log" );
	}
    }

}

if( $stack_size != 0 ) {
    y2error( "Unclosed sections: $stack_size" );
}

close( CONF );


while ( <STDIN> )
{
    y2debug( "Got $_" );
    my ($command, $path, $argument) = ycp::ParseCommand ($_);
    
    if ($command eq "Write")
    {
	if( $path eq ".Listen" or $path eq ".\"Listen\"" )
	{
	    @listen = @{$argument};
	    ycp::Return ( "true" );
	}
	elsif( $path eq ".CustomLog" or $path eq ".\"CustomLog\"" )
	{
	    @custom_log = @{$argument};
	    ycp::Return ( "true" );
	}
	elsif ( $path eq ".ErrorLog" or $path eq ".\"ErrorLog\"" )
	{
	    $error_log = $argument;
	    ycp::Return ( "true" );
	}
	elsif ( $path eq "." )
	{
	    # create a temporary file, then copy it over
	    my ($newconf, $filename) = mkstemp("/tmp/httpd.XXXXXXXX");
	    
	    y2debug( "Temporary file is $filename" );

	    if( not defined $newconf ) {
		y2error( "Cannot write to configuration file ''$httpd_conf'" );
		ycp::Return ("false");
	    } else 
	    {
		if( open( ORIGCONF, $httpd_conf ) ) {
		    # there is an original file
		    # copy the original, filter known values
		    @section_stack = ();
		
		    while( $line = <ORIGCONF> ) {
			# section start
			if( $line =~ /^\s*<([^\/\s]+).*>/ ) {
			    y2debug( "Pushing $1" );
			    push( @section_stack, $1 );
			    $stack_size = $stack_size+1;
			}
    
			# section end
			if( $line =~ /^\s*<\/([^\s]+).*>/ ) {
			    my $found_sect = $1;
			    my $exp_sect = pop( @section_stack );
			    y2debug( "Popped $1" );
			    if( $found_sect ne $exp_sect ) {
		    		y2error( "Non-matching section: found '$found_sect', expected '$exp_sect'" );
				push( @section_stack, $exp_sect );
			    } else {
				$stack_size = $stack_size-1;
			    }
			}
			
			# only top-level values
			if( $stack_size == 0 ) {
			    if( not ( $line =~ /^\s*(Listen|CustomLog|ErrorLog)\s+[^\s]+/ ) ) {
				print $newconf $line;
			    }
			} else { 
			    print $newconf $line;
			}
		    }
		    close( ORIGCONF );		
		}
	    
		# insert new config values
		foreach my $i ( @listen ) {
		    print $newconf "Listen $i\n";
		}
#		foreach my $i ( @custom_log ) {
#		    print $newconf "CustomLog $i\n";
#		}
#		if( defined $error_log && $error_log ne "" ) {
#		    print $newconf "ErrorLog $error_log\n";
#		}
	    
		close( $newconf );
	    
		# copy the file
		# what about access rights?
		my $exit = system( "cp -f $filename $httpd_conf" );
		if( $exit == 0 and -s $httpd_conf ) {
		    system( "rm -f $filename" );
		    ycp::Return ( "true" );
		} else {
		    y2error( "Cannot copy new configuration file to '$httpd_conf'" );
		    system( "rm -f $filename" );
		    ycp::Return ( "false" );
		}
	    }
	}
	else 
	{
	    y2error ("Unrecognized path! '$path'");
	    ycp::Return (undef);
	}
    }

    elsif ($command eq "Read")
    {

	if( $path eq ".Listen" or $path eq ".\"Listen\"" )
	{
	    ycp::Return (\@listen, 1 );
	}
	elsif( $path eq ".CustomLog" or $path eq ".\"CustomLog\"" )
	{
	    ycp::Return (\@custom_log, 1 );
	}
	elsif ( $path eq ".ErrorLog" or $path eq ".\"ErrorLog\"" )
	{
	    ycp::Return( $error_log, 1 );
	}
	else
	{
	    ycp::Return (undef);
	}
    }
    
    elsif ($command eq "Dir" )
    {
	if ($path eq ".") {
	    ycpReturnArrayAsList (@known_values);
	}
	else 
	{
	    y2error ("Don't know what to Dir from '$path'");
	    ycp::Return (undef);
	}
    }

    elsif ($command eq "result")
    {
	# FIXME: should write as well
	exit;
    }

    # Unknown command
    else
    {
	y2error ("Unknown instruction $command or argument: ", ref ($argument));
	ycp::Return (undef);
    }
    print "\n";
}
